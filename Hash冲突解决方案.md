# Hash冲突

​		`Hash`冲突是指，两个数经过`Hash`运算，最终存储的为止落在了同一个位置，不能同时存储这两个数据。

## 常见解决办法

### 开放定址法

​		这种方法也称**散列法**，基本思想是：当关键字key的哈希地址p出现冲突时，以当前地址为基准继续哈希，知道产生一个不冲突的地方。

### 拉链址法

​		借鉴`HashMap`的解决办法，在冲突的地方，添加一个链表，将冲突的key存储在链表里。

### 公共溢出区

​		将哈希表分为基本表和溢出表，当基本表发生冲突的元素时，填入溢出表

>开放定址法和拉链法比较：
>
>1. 拉链法处理冲突简单，无堆积现象；链表节点动态申请，更适合造表前无法确定表的长度
>2. 开放地址法不易删除节点，因为会截断在它之后填入散列表的同义词节点的查询路径。

## `HashMap`计算`hash`值

```java
static final int hash(Object var0) {
        int var1;
        return var0 == null ? 0 : (var1 = var0.hashCode()) ^ var1 >>> 16;
    }
```

>`^`异或运算：相同为0，不同为1
>
>`>>>`无符号右移：右移初2

​		在`HashMap`中，哈希值与数组长度取模然后得到最终落入位置。一般来说数组的长度小于`2^16 65536`，所以说`i`即落入位置始终是`Hash`的低16位与`length-1`进行`&`运算。

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict) {
    Node<K,V>[] tab; Node<K,V> p; int n, i;
    ...
    if ((p = tab[i = (n - 1) & hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    ...
```

​		这里`i`始终是`length-1`与`hash`的低16位进行`&`运算(就是取模)，

> 当`length = 2 ^ n`时，下标运算结果取决于哈希值的低N位。

#### 为什么在计算哈希值时要无符号右移16位并进行异或

​		**核心目的是提高哈希散列度，尽可能减少哈希冲突，从而提升数据的查找性能。**

​		`(n-1) & Hash`导致大量的`key`集中散列在相同的位置上

​		无符号右移在进行&运算：让`HashCode`的高位和地位进行组合，提高数组位置的散列度。